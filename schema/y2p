#!/usr/bin/env python

import sys
import yaml
import re
import subprocess
from collections import Counter
from inflector.languages.english import English

INFLECTOR = English()


def _get_git_tag():
    res = subprocess.run("git describe --tags --exact-match".split(), capture_output=True)
    if res.stderr.decode().startswith("fatal"):
        # if no exact tag, then get branch
        res = subprocess.run("git rev-parse --abbrev-ref HEAD".split(), capture_output=True)
    tag = res.stdout.decode().strip()
    return tag


def _parse_release_as_version(rls):
    m = re.match("^(\d+\.\d+)", rls)
    if m:
        return m.group(1).replace('.', '_')
    return rls


def snake_case(camel_case):
    return re.sub(r'(?<![A-Z])(?<!^)(?=[A-Z])', '_', camel_case).lower()


def indent(text, level):
    return '   ' * level + text


def simplify_reference(reference_string):
    try:
        return reference_string.split('/')[-1]
    except TypeError:
        return reference_string


def list_one_of(one_of_list):
    return [simplify_reference(ref) for ref in one_of_list]


class ProtoDoc:

    def __init__(self, definitions, version):
        self.header = f"""syntax = "proto3";

        package org.ga4gh.vrs.v{version};

        import "google/protobuf/timestamp.proto";

        option java_multiple_files = true;
        option java_package = "org.ga4gh.vrs.v{version}";

        """
        self.definitions = definitions
        self.messages = dict()
        self.dependencies = dict()
        self.abstract_types = set()
        self.simple_types = set()
        self._map_dependencies()
        self._build_messages()

    def _resolve_reference_and_store(self, reference, message):
        r = simplify_reference(reference)
        if r == message:
            return
        if self.definitions[r].get('type') == 'string':
            if r not in self.dependencies[message]:
                self.dependencies[message].append(r)
        elif 'properties' not in self.definitions[r]:
            self._register_dependency(self.definitions[r], message)
        else:
            if r not in self.dependencies[message]:
                self.dependencies[message].append(r)

    def _register_dependency(self, arg, message):
        if '$ref' in arg:
            self._resolve_reference_and_store(arg['$ref'], message)
        for conditional in ['oneOf', 'anyOf', 'allOf']:
            if conditional in arg:
                for sub_arg in arg[conditional]:
                    if '$ref' in sub_arg:
                        self._resolve_reference_and_store(sub_arg['$ref'], message)
        if arg.get('type') == 'array' and arg.get('items'):
            self._register_dependency(arg['items'], message)

    def _map_dependencies(self):
        for message, message_attributes in self.definitions.items():
            self.dependencies[message] = list()
            self._register_dependency(message_attributes, message)
            if 'properties' in message_attributes:
                for _, property_attributes in message_attributes['properties'].items():
                    self._register_dependency(property_attributes, message)
            elif message_attributes.get('type') == 'string':
                self.simple_types.add(message)
            else:
                self.abstract_types.add(message)

    def _build_message(self, message):
        for dependency in self.dependencies[message]:
            if dependency in self.messages:
                continue
            else:
                self._build_message(dependency)
        self.messages[message] = ProtoMessage(message, self)

    def _build_messages(self):
        for message in self.definitions:
            self._build_message(message)


class ProtoMessage:

    property_basic_types = {
        'string': 'string',
        'number': 'double',
        'integer': 'uint64',
        'boolean': 'bool'
    }

    def __init__(self, message_name, document):
        self.message_name = message_name
        self.document = document
        self.js_definition = document.definitions[message_name]
        self.deprecated = False
        self.properties = self.js_definition.get('properties', dict())
        t = self.js_definition.get('type', None)
        self.simple = (t == 'string')
        self.abstract = not (bool(t) or self.simple)
        self.nested = list()
        self.fields = list()
        self._build_fields()

    def __repr__(self):
        return f'{self.message_name} <ProtoMessage>'

    def _dereference(self, field_name, reference, n=None):
        k = simplify_reference(reference)
        m = self.document.messages.get(k)
        if k in self.document.simple_types:
            field = ProtoField(field_name, m.js_definition['type'], n, deprecated=m.deprecated)
        elif k not in self.document.abstract_types:
            field = ProtoField(field_name, m.message_name, n, deprecated=m.deprecated)
        else:
            raise ValueError
        return field

    def _dereference_and_rename(self, reference):
        s = simplify_reference(reference)
        field = self._dereference('temp', s)
        if s in self.document.simple_types:
            field.name = snake_case(s)
        else:
            field.name = snake_case(field.field_type)
        return field

    def _create_oneof_field(self, name, field_references):
        one_of_fields = list()
        for one_of_obj in field_references:
            s = simplify_reference(one_of_obj['$ref'])
            if s in self.document.abstract_types:
                for dep in self.document.dependencies[s]:
                    field = self._dereference_and_rename(dep)
                    one_of_fields.append(field)
            else:
                field = self._dereference_and_rename(s)
                one_of_fields.append(field)
        return ProtoField(name, 'oneof', None, nested=one_of_fields)

    def _build_fields(self):
        for prop, prop_attributes in self.properties.items():
            if prop == 'type':
                continue
            n = prop_attributes.get('protobuf_number')
            if '$ref' in prop_attributes:
                field = self._dereference(prop, prop_attributes['$ref'], n)
            elif prop_attributes.get('type') in self.property_basic_types:
                proto_type = self.property_basic_types[prop_attributes['type']]
                field = ProtoField(prop, proto_type, n)
            elif 'oneOf' in prop_attributes:
                field = self._create_oneof_field(prop, prop_attributes['oneOf'])
            elif 'allOf' in prop_attributes:
                assert [list(x.keys())[0] for x in prop_attributes['allOf']] == ['$ref', 'not']
                k = simplify_reference(prop_attributes['allOf'][0]['$ref'])
                group_dependencies = set(self.document.dependencies[k])
                not_field_ref = {simplify_reference(prop_attributes['allOf'][1]['not']['$ref'])}
                field_refs = group_dependencies - not_field_ref
                if len(field_refs) == 0:
                    raise SyntaxError(prop)
                elif len(field_refs) == 1:
                    field = self._dereference(prop, field_refs.pop(), n)
                else:
                    ordered_field_refs = [{'$ref': x} for x in self.document.dependencies[k] if x in field_refs]
                    field = self._create_oneof_field(prop, ordered_field_refs)
                    field
            else:
                x = 0
            self.fields.append(field)
        # TODO: Uniquify field names
        # TODO: Assign proto field values


class ProtoField:

    def __init__(self, name, field_type, number, nested=None, deprecated=False):
        self.name = name
        self.field_type = field_type
        self.number = number
        self.nested = nested
        self.deprecated = deprecated

    def __repr__(self):
        return f'{self.name} <ProtoField>'

    def __sub__(self, other):
        assert self.nested is not None
        kmap = dict()
        s = set()
        for x in self.nested:
            k = (x.name, x.field_type)
            s.add(k)
            kmap[k] = x
        if other.nested is None:
            s2 = {(other.name, other.field_type)}
        else:
            s2 = set([(x.name, x.field_type) for x in other.nested])
        r = s - s2
        if len(r) == 0:
            return None
        elif len(r) == 1:
            k = r.pop()
            return kmap[k]
        else:
            new = list()
            for x in self.nested:
                if (x.name, x.field_type) in r:
                    new.append(x)
            return ProtoField(self.name, self.field_type, self.number, new, self.deprecated)

class ProtoMessageOld:

    def __init__(self, message_obj, abstract_map, deprecated_types, document, level=0):
        self.obj = message_obj
        self.props = message_obj['properties']
        self.abstract_map = abstract_map
        self.deprecated_types = deprecated_types
        self.message_type = self.props["type"]["default"]
        self.attributes = [indent(f'message {self.message_type} {{', level)]
        self.attribute_index = 1
        for name, value in message_obj['properties'].items():
            self._create_proto_attribute(name, value, level + 1)
        self._uniquify_attributes()
        self.attributes.append(indent('}', level))

    def _uniquify_attributes(self):
        observed = Counter()
        attribute_re = re.compile(r'^(\s+)(\w+) (\w+)( =.*)$')
        for attribute in self.attributes:
            match = attribute_re.match(attribute)
            if match:
                spaces, att_type, att_name, assignment = match.groups()
                observed[(att_type, att_name)] += 1
        parent = self.message_type
        parent_re = re.compile(r'\s+oneof (\w+)')
        for i, attribute in enumerate(self.attributes):
            match = parent_re.match(attribute)
            if match:
                parent = match.group(1)
                continue
            match = attribute_re.match(attribute)
            if match:
                spaces, att_type, att_name, assignment = match.groups()
                if observed[(att_type, att_name)] > 1:
                    new = f'{spaces}{att_type} {parent}_{att_name}{assignment}'
                    self.attributes[i] = new

    def emit(self):
        for attribute in self.attributes:
            print(attribute)

    def _register_attribute(self, name, t, level):
        if t in self.property_basic_types:
            out = f'{self.property_basic_types[t]} {name} = {self.attribute_index};'
        else:
            out = f'{t} {name} = {self.attribute_index};'
        self.attributes.append(indent(out, level))
        self.attribute_index += 1

    def _register_attribute_set(self, name, collected_properties, level):
        self.attributes.append(indent(f'oneof {name} {{', level))
        for cp_name, cp_type in sorted(collected_properties):
            self._register_attribute(cp_name, cp_type, level + 1)
        self.attributes.append(indent('}', level))

    def _create_proto_attribute(self, name, value, level):
        if name == 'type':
            return
        if 'oneOf' in value:
            collected_properties = set()
            for type_ref in list_one_of(value['oneOf']):
                if type_ref in self.abstract_map:
                    collected_properties.update(self._collect_properties(type_ref))
                elif type_ref not in self.deprecated_types:
                    collected_properties.add((snake_case(type_ref), type_ref))
            self._register_attribute_set(name, collected_properties, level)
            return
        if '$ref' in value:
            t = simplify_reference(value)
        else:
            t = value['type']

        if t in self.property_basic_types:
            self._register_attribute(name, t, level)
        elif t in self.abstract_map:
            collected_properties = self._collect_properties(t)
            if len(collected_properties) == 1:
                self._register_attribute(name, collected_properties.pop()[1], level)
            else:
                self._register_attribute_set(name, collected_properties, level)
        elif t == 'array':
            # Currently arrays all rely on repeated oneOf structures, not
            # supported by protobuf. This section handles that challenge, but
            # A generalized strategy may need to be defined in the future for
            # other array structures.
            assert len(value['items']['oneOf']) > 1
            nested_message_properties = {
                'type': {'default': INFLECTOR.titleize(INFLECTOR.singularize(name))},
                'value': value['items']
            }
            nested_message_obj = {
                'description': 'An auto-generated nested message.',
                'properties': nested_message_properties
            }
            nested_message = ProtoMessageOld(
                nested_message_obj, self.abstract_map,
                self.deprecated_types, level
            )
            self.attributes.extend(nested_message.attributes)
            self._register_attribute(name, f'repeated {nested_message.message_type}', level)
        else:
            self._register_attribute(name, t, level)

    def _collect_properties(self, abstract_type):
        mapped_types = self.abstract_map[abstract_type]
        out = set()
        for mapped_type in mapped_types:
            if mapped_type in self.deprecated_types:
                continue
            if mapped_type in self.abstract_map:
                out.update(self._collect_properties(mapped_type))
            elif mapped_type in self.property_basic_types:
                out.add((snake_case(abstract_type), self.property_basic_types[mapped_type]))
            else:
                out.add((snake_case(mapped_type), mapped_type))
        return out


def main(version):
    yaml_dict = yaml.load(sys.stdin, Loader=yaml.SafeLoader)
    doc = ProtoDoc(yaml_dict['definitions'], version)
    x = 0


if __name__ == '__main__':
    main(version='1')
