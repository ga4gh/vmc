#!/usr/bin/env python

import sys
import yaml
import re
import subprocess
from collections import Counter
from inflector.languages.english import English

INFLECTOR = English()


def _get_git_tag():
    res = subprocess.run("git describe --tags --exact-match".split(), capture_output=True)
    if res.stderr.decode().startswith("fatal"):
        # if no exact tag, then get branch
        res = subprocess.run("git rev-parse --abbrev-ref HEAD".split(), capture_output=True)
    tag = res.stdout.decode().strip()
    return tag


def _parse_release_as_version(rls):
    m = re.match("^(\d+\.\d+)", rls)
    if m:
        return m.group(1).replace('.', '_')
    return rls


def snake_case(camel_case):
    return re.sub(r'(?<![A-Z])(?<!^)(?=[A-Z])', '_', camel_case).lower()


def indent(text, level):
    return '   ' * level + text


def simplify_reference(reference_string):
    try:
        return reference_string.split('/')[-1]
    except TypeError:
        return reference_string


def list_one_of(one_of_list):
    return [simplify_reference(ref) for ref in one_of_list]


class ProtoDoc:

    def __init__(self, definitions, version):
        self.header = f"""syntax = "proto3";

        package org.ga4gh.vrs.v{version};

        import "google/protobuf/timestamp.proto";

        option java_multiple_files = true;
        option java_package = "org.ga4gh.vrs.v{version}";

        """
        self.definitions = definitions
        self.messages = dict()
        self.dependencies = dict()
        self._map_dependencies()
        self._build_messages()

    def _register_dependency(self, arg, message):
        if '$ref' in arg:
            x = simplify_reference(arg['$ref'])
            self.dependencies[message].add(x)
        for conditional in ['oneOf', 'anyOf', 'allOf']:
            if conditional in arg:
                for sub_arg in arg[conditional]:
                    if '$ref' in sub_arg:
                        x = simplify_reference(sub_arg['$ref'])
                        self.dependencies[message].add(x)
        if arg.get('type') == 'array' and arg.get('items'):
            self._register_dependency(arg['items'], message)

    def _map_dependencies(self):
        for message, message_attributes in self.definitions.items():
            self.dependencies[message] = set()
            self._register_dependency(message_attributes, message)
            if 'properties' in message_attributes:
                for _, property_attributes in message_attributes['properties'].items():
                    self._register_dependency(property_attributes, message)

    def _build_message(self, message):
        for dependency in self.dependencies[message]:
            if dependency in self.messages:
                continue
            else:
                self._build_message(dependency)
        self.messages[message] = ProtoMessage(message, self)

    def _build_messages(self):
        for message in self.definitions:
            self._build_message(message)


class ProtoMessage:

    property_basic_types = {
        'string': 'string',
        'number': 'double',
        'integer': 'uint64',
        'boolean': 'bool'
    }

    def __init__(self, message_name, document):
        self.message_name = message_name
        self.document = document
        self.js_definition = document.definitions[message_name]
        self.deprecated = False
        self.properties = self.js_definition.get('properties', dict())
        t = self.js_definition.get('type', None)
        self.simple = (t == 'string')
        self.abstract = not (bool(t) or self.simple)
        self.nested = list()
        self.fields = list()
        self._build_fields()

    def _dereference(self, field_name, reference, n):
        k = simplify_reference(reference)
        m = self.document.messages[k]
        if m.simple:
            field = ProtoField(field_name, m.js_definition['type'], n, deprecated=m.deprecated)
        elif not m.abstract:
            field = ProtoField(field_name, m.message_name, n, deprecated=m.deprecated)
        else:
            raise NotImplementedError
        return field

    def _build_fields(self):
        for prop, prop_attributes in self.properties.items():
            if prop == 'type':
                continue
            n = prop_attributes.get('protobuf_number')
            if '$ref' in prop_attributes:
                field = self._dereference(prop, prop_attributes['$ref'], n)
            elif prop_attributes.get('type') in self.property_basic_types:
                proto_type = self.property_basic_types[prop_attributes['type']]
                field = ProtoField(prop, proto_type, n)
            else:
                raise NotImplementedError
            self.fields.append(field)


class ProtoField:

    def __init__(self, name, field_type, number, nested=None, deprecated=False):
        self.name = name
        self.field_type = field_type
        self.number = number
        self.nested = nested
        self.deprecated = deprecated


class ProtoMessageOld:

    def __init__(self, message_obj, abstract_map, deprecated_types, document, level=0):
        self.obj = message_obj
        self.props = message_obj['properties']
        self.abstract_map = abstract_map
        self.deprecated_types = deprecated_types
        self.message_type = self.props["type"]["default"]
        self.attributes = [indent(f'message {self.message_type} {{', level)]
        self.attribute_index = 1
        for name, value in message_obj['properties'].items():
            self._create_proto_attribute(name, value, level + 1)
        self._uniquify_attributes()
        self.attributes.append(indent('}', level))

    def _uniquify_attributes(self):
        observed = Counter()
        attribute_re = re.compile(r'^(\s+)(\w+) (\w+)( =.*)$')
        for attribute in self.attributes:
            match = attribute_re.match(attribute)
            if match:
                spaces, att_type, att_name, assignment = match.groups()
                observed[(att_type, att_name)] += 1
        parent = self.message_type
        parent_re = re.compile(r'\s+oneof (\w+)')
        for i, attribute in enumerate(self.attributes):
            match = parent_re.match(attribute)
            if match:
                parent = match.group(1)
                continue
            match = attribute_re.match(attribute)
            if match:
                spaces, att_type, att_name, assignment = match.groups()
                if observed[(att_type, att_name)] > 1:
                    new = f'{spaces}{att_type} {parent}_{att_name}{assignment}'
                    self.attributes[i] = new

    def emit(self):
        for attribute in self.attributes:
            print(attribute)

    def _register_attribute(self, name, t, level):
        if t in self.property_basic_types:
            out = f'{self.property_basic_types[t]} {name} = {self.attribute_index};'
        else:
            out = f'{t} {name} = {self.attribute_index};'
        self.attributes.append(indent(out, level))
        self.attribute_index += 1

    def _register_attribute_set(self, name, collected_properties, level):
        self.attributes.append(indent(f'oneof {name} {{', level))
        for cp_name, cp_type in sorted(collected_properties):
            self._register_attribute(cp_name, cp_type, level + 1)
        self.attributes.append(indent('}', level))

    def _create_proto_attribute(self, name, value, level):
        if name == 'type':
            return
        if 'oneOf' in value:
            collected_properties = set()
            for type_ref in list_one_of(value['oneOf']):
                if type_ref in self.abstract_map:
                    collected_properties.update(self._collect_properties(type_ref))
                elif type_ref not in self.deprecated_types:
                    collected_properties.add((snake_case(type_ref), type_ref))
            self._register_attribute_set(name, collected_properties, level)
            return
        if '$ref' in value:
            t = simplify_reference(value)
        else:
            t = value['type']

        if t in self.property_basic_types:
            self._register_attribute(name, t, level)
        elif t in self.abstract_map:
            collected_properties = self._collect_properties(t)
            if len(collected_properties) == 1:
                self._register_attribute(name, collected_properties.pop()[1], level)
            else:
                self._register_attribute_set(name, collected_properties, level)
        elif t == 'array':
            # Currently arrays all rely on repeated oneOf structures, not
            # supported by protobuf. This section handles that challenge, but
            # A generalized strategy may need to be defined in the future for
            # other array structures.
            assert len(value['items']['oneOf']) > 1
            nested_message_properties = {
                'type': {'default': INFLECTOR.titleize(INFLECTOR.singularize(name))},
                'value': value['items']
            }
            nested_message_obj = {
                'description': 'An auto-generated nested message.',
                'properties': nested_message_properties
            }
            nested_message = ProtoMessageOld(
                nested_message_obj, self.abstract_map,
                self.deprecated_types, level
            )
            self.attributes.extend(nested_message.attributes)
            self._register_attribute(name, f'repeated {nested_message.message_type}', level)
        else:
            self._register_attribute(name, t, level)

    def _collect_properties(self, abstract_type):
        mapped_types = self.abstract_map[abstract_type]
        out = set()
        for mapped_type in mapped_types:
            if mapped_type in self.deprecated_types:
                continue
            if mapped_type in self.abstract_map:
                out.update(self._collect_properties(mapped_type))
            elif mapped_type in self.property_basic_types:
                out.add((snake_case(abstract_type), self.property_basic_types[mapped_type]))
            else:
                out.add((snake_case(mapped_type), mapped_type))
        return out


def main(version):
    yaml_dict = yaml.load(sys.stdin, Loader=yaml.SafeLoader)
    ProtoDoc(yaml_dict['definitions'], version)


if __name__ == '__main__':
    main(version='1')
